<div class="container">
    <h1>.NET Core Enterprise Patterns ve Mimari Yapılar</h1>
    
    <div class="info-box">
        <strong>Dokümantasyon Kapsamı:</strong> Bu doküman, enterprise seviye .NET Core uygulamalarında kullanılan design pattern'leri, mimari yaklaşımları ve best practice'leri detaylı olarak ele almaktadır. Her pattern için problem analizi, çözüm yaklaşımı ve kullanım senaryoları açıklanmıştır.
    </div>

    <h2 id="generic-repo">Generic Repository Pattern</h2>
    
    <h3 id="generic-repo-problem">Problem Analizi</h3>
    <p>Geleneksel repository implementasyonlarında her entity için ayrı repository class'ları oluşturulması gerekmektedir. Bu yaklaşım şu problemleri doğurur:</p>
    
    <ul>
        <li>Her entity için tekrarlanan CRUD metodları</li>
        <li>Kod duplikasyonu ve bakım maliyeti artışı</li>
        <li>Yeni entity eklendiğinde manuel repository oluşturma zorunluluğu</li>
        <li>Tutarsız metod isimlendirmeleri ve implementasyonlar</li>
    </ul>

    <h3 id="generic-repo-solution">Çözüm Yapısı</h3>
    <p>Generic Repository, C# generic type sistemini kullanarak tüm entity'ler için ortak bir repository interface ve implementasyonu sağlar. Bu yaklaşım şu bileşenlerden oluşur:</p>

    <h4>Temel Interface Yapısı</h4>
    <p>Generic Repository interface'i tipik olarak şu metodları içerir:</p>
    <ul>
        <li><code>GetByIdAsync(TId id)</code> - Primary key ile tekil kayıt sorgulama</li>
        <li><code>GetAllAsync()</code> - Tüm kayıtları sorgulama</li>
        <li><code>FindAsync(Expression&lt;Func&lt;T, bool&gt;&gt; predicate)</code> - Lambda expression ile filtreleme</li>
        <li><code>AddAsync(T entity)</code> - Yeni kayıt ekleme</li>
        <li><code>AddRangeAsync(IEnumerable&lt;T&gt; entities)</code> - Toplu kayıt ekleme</li>
        <li><code>Update(T entity)</code> - Kayıt güncelleme</li>
        <li><code>Remove(T entity)</code> - Kayıt silme</li>
        <li><code>RemoveRange(IEnumerable&lt;T&gt; entities)</code> - Toplu silme</li>
    </ul>

    <div class="info-box">
        <strong>IQueryable vs IEnumerable:</strong> Generic Repository'de <code>GetAll()</code> metodunun <code>IQueryable&lt;T&gt;</code> dönmesi önerilir. Bu sayede sorgular veritabanına gitmeden önce composition yapılabilir (deferred execution). <code>IEnumerable&lt;T&gt;</code> kullanımı tüm veriyi memory'ye çeker ve performans problemlerine yol açar.
    </div>

    <h3 id="generic-repo-when">Kullanım Senaryoları ve Kısıtlamalar</h3>
    
    <h4>Uygun Kullanım Senaryoları:</h4>
    <ul>
        <li>Standart CRUD operasyonları gerektiren entity'ler</li>
        <li>Basit sorgulama ihtiyaçları olan projeler</li>
        <li>Hızlı prototipleme ve MVP geliştirme</li>
    </ul>

    <h4>Uygun Olmayan Senaryolar:</h4>
    <ul>
        <li>Karmaşık business logic içeren domain modeller</li>
        <li>Entity'ye özel sorgulama gereksinimleri (örn: <code>GetUserByEmail</code>, <code>GetActiveProducts</code>)</li>
        <li>Aggregate root'lar ve domain-driven design yaklaşımları</li>
    </ul>

    <div class="warning-box">
        <strong>Anti-Pattern Uyarısı:</strong> Generic Repository'yi her durumda kullanmak bir anti-pattern'dir. Entity Framework Core zaten bir Repository Pattern implementasyonudur (DbSet). Generic Repository üzerine bir katman daha eklemek gereksiz abstraction yaratabilir. Kullanım kararı proje gereksinimlerine göre verilmelidir.
    </div>

    <h4>Genişletme Stratejisi:</h4>
    <p>Entity'ye özel metodlar gerektiğinde inheritance kullanılır:</p>
    <p><code>IUserRepository : IGenericRepository&lt;User&gt;</code> şeklinde extend edilerek özel metodlar eklenebilir.</p>

    <h2 id="unit-of-work">Unit of Work Pattern</h2>

    <h3 id="uow-transaction">Transaction Yönetimi</h3>
    <p>Unit of Work Pattern, bir business transaction içindeki tüm veritabanı işlemlerini tek bir iş birimi olarak yönetir. ACID prensiplerini uygulayarak veri tutarlılığını garanti eder.</p>

    <h4>Core Prensipleri:</h4>
    <ul>
        <li><strong>Atomicity:</strong> Tüm işlemler ya tamamen başarılı olur ya da hiçbiri olmaz</li>
        <li><strong>Consistency:</strong> Veritabanı her zaman geçerli bir durumda kalır</li>
        <li><strong>Isolation:</strong> Eş zamanlı işlemler birbirini etkilemez</li>
        <li><strong>Durability:</strong> Commit edilen değişiklikler kalıcıdır</li>
    </ul>

    <h3 id="uow-implementation">Implementasyon Detayları</h3>
    
    <h4>Temel Sorumluluklar:</h4>
    <ul>
        <li>Tüm repository instance'larını merkezi olarak yönetme</li>
        <li>DbContext lifecycle'ını kontrol etme</li>
        <li>Transaction başlatma, commit ve rollback işlemleri</li>
        <li>Change tracking mekanizmasını yönetme</li>
    </ul>

    <div class="info-box">
        <strong>SaveChanges Stratejisi:</strong> Unit of Work içinde <code>SaveChanges()</code> sadece bir kez, tüm işlemler tamamlandıktan sonra çağrılır. Bu yaklaşım hem performance açısından optimize edilmiştir hem de transaction bütünlüğünü garanti eder. Her repository işleminden sonra ayrı ayrı save yapmak transaction avantajını ortadan kaldırır.
    </div>

    <h4>Dispose Pattern Implementasyonu:</h4>
    <p>Unit of Work, <code>IDisposable</code> interface'ini implement etmelidir. DbContext'in düzgün dispose edilmesi memory leak'leri önler ve connection pool'u verimli kullanır.</p>

    <div class="note-box">
        <strong>Entity Framework Core ile İlişki:</strong> EF Core'da <code>DbContext</code> zaten Unit of Work pattern'ini implement eder. Ancak birden fazla repository'yi koordine etmek ve business logic'i clean tutmak için explicit Unit of Work implementasyonu tercih edilir. Bu yaklaşım özellikle multiple DbContext senaryolarında kritik öneme sahiptir.
    </div>

    <h2 id="cqrs">CQRS (Command Query Responsibility Segregation)</h2>

    <h3 id="cqrs-concept">Temel Konsept ve Filozofi</h3>
    <p>CQRS, Martin Fowler tarafından popülarize edilen bir mimari pattern'dir. Sistemdeki okuma (query) ve yazma (command) operasyonlarını farklı modeller ve işlem akışları ile ayırır.</p>

    <h4>Separation of Concerns Prensibi:</h4>
    <table class="comparison-table">
        <tr>
            <th>Operasyon Tipi</th>
            <th>Command (Yazma)</th>
            <th>Query (Okuma)</th>
        </tr>
        <tr>
            <td>Amaç</td>
            <td>State değişikliği yapmak</td>
            <td>Data okumak</td>
        </tr>
        <tr>
            <td>Return Type</td>
            <td>Void veya Result (data döndürmez)</td>
            <td>DTO, ViewModel vb.</td>
        </tr>
        <tr>
            <td>Validation</td>
            <td>Karmaşık business rule validation</td>
            <td>Minimal veya yok</td>
        </tr>
        <tr>
            <td>Caching</td>
            <td>Kullanılmaz</td>
            <td>Agresif caching stratejileri</td>
        </tr>
        <tr>
            <td>Transaction</td>
            <td>Gerekli</td>
            <td>Genellikle gereksiz</td>
        </tr>
    </table>

    <h4>Command Yapısı:</h4>
    <p>Command'ler business intent'i temsil eder ve şu özelliklere sahiptir:</p>
    <ul>
        <li>İmperative naming convention (CreateOrder, UpdateUser, DeleteProduct)</li>
        <li>Input parametreleri DTO olarak taşır</li>
        <li>Validation logic içerir</li>
        <li>Domain event'leri tetikleyebilir</li>
        <li>Return type genelde void veya Result pattern kullanır</li>
    </ul>

    <h4>Query Yapısı:</h4>
    <p>Query'ler veri okuma ihtiyacını karşılar:</p>
    <ul>
        <li>Descriptive naming (GetUserById, GetProductList, SearchOrders)</li>
        <li>Optimized read models kullanır</li>
        <li>Projection ve DTO mapping içerir</li>
        <li>Caching layer'ı ile entegre edilebilir</li>
        <li>Spesifik DTO'lar döndürür</li>
    </ul>

    <h3 id="cqrs-mediatr">MediatR ile CQRS Implementasyonu</h3>
    <p>MediatR, CQRS pattern'ini implement etmek için kullanılan in-process messaging kütüphanesidir. Request-Response ve Notification pattern'lerini destekler.</p>

    <h4>IRequest ve IRequestHandler Interface'leri:</h4>
    <ul>
        <li><code>IRequest&lt;TResponse&gt;</code>: Command ve Query'leri temsil eder</li>
        <li><code>IRequestHandler&lt;TRequest, TResponse&gt;</code>: İşleyici logic'i içerir</li>
        <li><code>INotification</code>: Domain event'leri için kullanılır</li>
        <li><code>INotificationHandler&lt;TNotification&gt;</code>: Event handler'ları implement eder</li>
    </ul>

    <div class="success-box">
        <strong>MediatR Avantajları:</strong>
        <ul>
            <li><strong>Loose Coupling:</strong> Controller'lar handler'lara direkt bağımlı değildir</li>
            <li><strong>Single Responsibility:</strong> Her handler tek bir işten sorumludur</li>
            <li><strong>Pipeline Behaviors:</strong> Cross-cutting concern'ler merkezi olarak yönetilir</li>
            <li><strong>Testability:</strong> Unit test yazımı kolaylaşır</li>
        </ul>
    </div>

    <h3 id="cqrs-when">Ne Zaman CQRS Kullanılmalı</h3>

    <h4>CQRS Uygun Olduğu Durumlar:</h4>
    <ul>
        <li>Okuma ve yazma operasyonlarının farklı performans gereksinimleri olduğunda</li>
        <li>Karmaşık domain logic ve business rule'lar mevcut olduğunda</li>
        <li>Farklı takımların read ve write tarafını bağımsız geliştirmesi gerektiğinde</li>
        <li>Eventual consistency kabul edilebilir olduğunda</li>
        <li>Event sourcing implementasyonu planlanıyorsa</li>
    </ul>

    <h4>CQRS Kullanılmaması Gereken Durumlar:</h4>
    <ul>
        <li>Basit CRUD operasyonları dominant olduğunda</li>
        <li>Küçük ölçekli projeler ve prototiplerde</li>
        <li>Takımın pattern'e hakimiyeti yoksa</li>
        <li>Over-engineering riski varsa</li>
    </ul>

    <div class="warning-box">
        <strong>Kompleksite Uyarısı:</strong> CQRS, uygulama kompleksitesini artırır. Read ve write model'larını senkronize etmek, eventual consistency'yi yönetmek ve ek infrastructure kodları gerektirir. Basit projelerde kullanımı premature optimization olarak değerlendirilir ve teknik borç yaratabilir.
    </div>

    <h2 id="mediatr">MediatR Pattern Detayları</h2>

    <h3 id="mediatr-concept">Mediator Pattern Kavramı</h3>
    <p>Mediator pattern, nesneler arasındaki iletişimi merkezi bir mediator üzerinden yöneterek loose coupling sağlar. Gang of Four design patterns'inden biridir.</p>

    <h4>Problem: Tight Coupling</h4>
    <p>Geleneksel yaklaşımda Controller'lar doğrudan Service layer'a bağımlıdır:</p>
    <ul>
        <li>Controller → UserService, ProductService, OrderService...</li>
        <li>Her service için constructor injection gerekir</li>
        <li>Service değişikliği controller'ı etkiler</li>
        <li>Test setup karmaşıklaşır</li>
    </ul>

    <h4>Çözüm: Mediator</h4>
    <p>MediatR ile controller sadece IMediator'a bağımlıdır:</p>
    <ul>
        <li>Controller → IMediator → Handler</li>
        <li>Tek bir dependency injection</li>
        <li>Handler'lar bağımsız olarak test edilebilir</li>
        <li>Yeni handler eklemek controller'ı etkilemez</li>
    </ul>

    <h3 id="mediatr-pipeline">Pipeline Behaviors</h3>
    <p>MediatR'ın en güçlü özelliklerinden biri Pipeline Behavior'lardır. Request-Response akışına middleware ekleyerek cross-cutting concern'leri merkezi olarak yönetir.</p>

    <h4>Yaygın Pipeline Behavior Kullanımları:</h4>
    <table>
        <tr>
            <th>Behavior</th>
            <th>Amaç</th>
            <th>Uygulama Alanı</th>
        </tr>
        <tr>
            <td>Validation Behavior</td>
            <td>FluentValidation ile otomatik validasyon</td>
            <td>Tüm command'ler</td>
        </tr>
        <tr>
            <td>Logging Behavior</td>
            <td>Request/Response loglama</td>
            <td>Tüm request'ler</td>
        </tr>
        <tr>
            <td>Performance Behavior</td>
            <td>Uzun süren işlemleri tespit etme</td>
            <td>Kritik operasyonlar</td>
        </tr>
        <tr>
            <td>Transaction Behavior</td>
            <td>Otomatik transaction yönetimi</td>
            <td>Command'ler</td>
        </tr>
        <tr>
            <td>Caching Behavior</td>
            <td>Response caching</td>
            <td>Query'ler</td>
        </tr>
        <tr>
            <td>Authorization Behavior</td>
            <td>Yetki kontrolü</td>
            <td>Güvenlik gerektiren işlemler</td>
        </tr>
    </table>

    <div class="info-box">
        <strong>Pipeline Execution Order:</strong> Behavior'lar registration sırasına göre çalışır. Tipik sıralama: Logging → Validation → Authorization → Transaction → Handler. Bu sıralama değiştirilebilir ancak logical akışı bozmamak önemlidir.
    </div>

    <h4>Validation Pipeline Örnek Akış:</h4>
    <ol>
        <li>Request Controller'a gelir</li>
        <li>IMediator.Send() çağrılır</li>
        <li>ValidationBehavior devreye girer</li>
        <li>FluentValidation rules çalışır</li>
        <li>Validation başarısızsa ValidationException fırlatılır</li>
        <li>Başarılıysa Handler'a iletilir</li>
        <li>Handler response döner</li>
        <li>Response Controller'a geri döner</li>
    </ol>

    <h2 id="response-pattern">Response Pattern (API Standardization)</h2>

    <h3>Problem: Tutarsız API Response'ları</h3>
    <p>Farklı endpoint'lerin farklı response formatları döndürmesi şu problemleri yaratır:</p>
    <ul>
        <li>Frontend'de her endpoint için farklı error handling</li>
        <li>Kullanıcıya gösterilecek mesajların tutarsız formatları</li>
        <li>HTTP status code'larının yanlış kullanımı</li>
        <li>API dokümantasyonunun karmaşıklaşması</li>
    </ul>

    <h3>Standart Response Yapısı</h3>
    <p>Response Pattern, tüm API endpoint'leri için tutarlı bir yanıt yapısı tanımlar:</p>

    <table>
        <tr>
            <th>Property</th>
            <th>Type</th>
            <th>Açıklama</th>
        </tr>
        <tr>
            <td>success</td>
            <td>bool</td>
            <td>İşlem başarı durumu</td>
        </tr>
        <tr>
            <td>message</td>
            <td>string</td>
            <td>Kullanıcıya gösterilecek mesaj</td>
        </tr>
        <tr>
            <td>data</td>
            <td>T (generic)</td>
            <td>Response payload</td>
        </tr>
        <tr>
            <td>errors</td>
            <td>List&lt;string&gt;</td>
            <td>Validasyon hataları</td>
        </tr>
        <tr>
            <td>statusCode</td>
            <td>int</td>
            <td>HTTP status code</td>
        </tr>
        <tr>
            <td>timestamp</td>
            <td>DateTime</td>
            <td>Response zamanı</td>
        </tr>
    </table>

    <div class="info-box">
        <strong>Generic Response Types:</strong> İki temel response type kullanılır:
        <ul>
            <li><code>ApiResponse</code>: Data içermeyen response'lar için (örn: Delete işlemi)</li>
            <li><code>ApiResponse&lt;T&gt;</code>: Generic data içeren response'lar için</li>
        </ul>
    </div>

    <h3>HTTP Status Code Best Practices</h3>
    <table>
        <tr>
            <th>Status Code</th>
            <th>Kullanım</th>
            <th>Örnek Senaryo</th>
        </tr>
        <tr>
            <td>200 OK</td>
            <td>Başarılı GET, PUT işlemleri</td>
            <td>Kullanıcı detayı getirildi</td>
        </tr>
        <tr>
            <td>201 Created</td>
            <td>Başarılı POST işlemi</td>
            <td>Yeni ürün oluşturuldu</td>
        </tr>
        <tr>
            <td>204 No Content</td>
            <td>Başarılı DELETE işlemi</td>
            <td>Kayıt silindi</td>
        </tr>
        <tr>
            <td>400 Bad Request</td>
            <td>Validation hataları</td>
            <td>Email formatı geçersiz</td>
        </tr>
        <tr>
            <td>401 Unauthorized</td>
            <td>Authentication gerekli</td>
            <td>Token eksik veya geçersiz</td>
        </tr>
        <tr>
            <td>403 Forbidden</td>
                <td>Yetki yetersiz (Rol/Policy hatası)</td>
                <td>Admin paneline erişim denemesi</td>
            </tr>
            <tr>
                <td>404 Not Found</td>
                <td>Kaynak bulunamadı</td>
                <td>ID ile kayıt arama sonucu boş</td>
            </tr>
            <tr>
                <td>500 Server Error</td>
                <td>Beklenmeyen hata</td>
                <td>Database bağlantı kopukluğu</td>
            </tr>
        </table>

        <h2 id="result-pattern">Result Pattern</h2>
        
        <p>Result Pattern, Service katmanından Controller'a veya katmanlar arası veri taşırken kullanılan, işlemin sonucunu ve veriyi kapsülleyen bir yapıdır. Exception fırlatmak yerine "başarısızlık" durumunu bir nesne olarak döndürmeyi hedefler.</p>

        <div class="info-box">
            <strong>Exception vs Result:</strong> Business logic akışında (örneğin "Bakiye yetersiz") Exception fırlatmak performans maliyetlidir (Stack trace oluşumu). Bunun yerine <code>Result.Failure("Bakiye yetersiz")</code> döndürmek hem daha hızlıdır hem de akış kontrolünü kolaylaştırır.
        </div>

        <h3>Yapısal Bileşenler</h3>
        <ul>
            <li><strong>IsSuccess:</strong> İşlemin başarılı olup olmadığını belirten boolean.</li>
            <li><strong>Value:</strong> Başarılı durumda taşınan veri.</li>
            <li><strong>Error:</strong> Başarısız durumda hata mesajı veya hata objesi.</li>
            <li><strong>ValidationErrors:</strong> Varsa validasyon hatalarının listesi.</li>
        </ul>

        <h4>Kod Örneği (Implicit Operators):</h4>
        <pre><code>
public class Result<T>
{
    public bool IsSuccess { get; }
    public T Value { get; }
    public string Error { get; }

    // Implicit conversion sayesinde kod temizliği
    public static implicit operator Result<T>(T value) => Success(value);
    public static implicit operator Result<T>(string error) => Failure(error);
}
        </code></pre>

        <h2 id="multi-db">Multiple Database Kullanımı</h2>

        <h3 id="multi-db-same">Aynı Tip DB (Sharding/Tenancy)</h3>
        <p>Multi-tenant uygulamalarda veya sharding senaryolarında, şema aynı olsa da veritabanı sunucusu veya veritabanı adı değişebilir.</p>
        
        <ul>
            <li><strong>DbContextFactory:</strong> Her request'te tenant ID'ye göre connection string dinamik olarak belirlenir.</li>
            <li><strong>Catalog Pattern:</strong> Ana bir veritabanında hangi tenant'ın hangi connection string'i kullanacağı tutulur.</li>
        </ul>

        <h3 id="multi-db-different">Farklı Tip DB (Polyglot Persistence)</h3>
        <p>Modern mimarilerde her veri tipi için en uygun veritabanı teknolojisi seçilir. CQRS bu yapıyı destekler.</p>

        <table class="comparison-table">
            <tr>
                <th>Veritabanı Tipi</th>
                <th>Kullanım Alanı</th>
                <th>Örnek Teknoloji</th>
            </tr>
            <tr>
                <td>Relational (RDBMS)</td>
                <td>İlişkisel veriler, Transactional işlemler (Write Side)</td>
                <td>SQL Server, PostgreSQL</td>
            </tr>
            <tr>
                <td>NoSQL (Document)</td>
                <td>Ürün katalogları, JSON veriler, Read Side</td>
                <td>MongoDB, Couchbase</td>
            </tr>
            <tr>
                <td>Key-Value Store</td>
                <td>Caching, Session yönetimi</td>
                <td>Redis</td>
            </tr>
            <tr>
                <td>Search Engine</td>
                <td>Full-text search, Log analizi</td>
                <td>Elasticsearch</td>
            </tr>
        </table>

        <div class="note-box">
            <strong>Distributed Transaction Sorunu:</strong> Birden fazla veritabanına aynı anda yazma işlemi yapıldığında (örneğin SQL'e sipariş, Mongo'ya log atma) veri bütünlüğü risk altındadır. Bu durumda <strong>Saga Pattern</strong> veya <strong>Outbox Pattern</strong> kullanılmalıdır.
        </div>

        <h2 id="advanced">İleri Seviye Konular</h2>
        
        <h3>1. Specification Pattern</h3>
        <p>Generic Repository pattern'deki <code>Expression&lt;Func&lt;T, bool&gt;&gt;</code> karmaşasını önlemek için kullanılır. İş kurallarını (sorguları) yeniden kullanılabilir nesneler haline getirir.</p>

        <h3>2. Options Pattern</h3>
        <p><code>appsettings.json</code> içerisindeki konfigürasyonları, strongly-typed sınıflara mapleyerek dependency injection ile yönetmeyi sağlar. <code>IOptions</code>, <code>IOptionsSnapshot</code> ve <code>IOptionsMonitor</code> arayüzleri ile canlı konfigürasyon takibi yapılabilir.</p>

        <h3>3. Background Services (Hosted Services)</h3>
        <p>Uygulama ayağa kalktığında veya belirli periyotlarda çalışması gereken işler için kullanılır (Email kuyruğu eritme, Cache yenileme vb.).</p>
        
        <div class="success-box">
            <strong>Sonuç:</strong> Bu dokümantasyonda ele alınan pattern'ler, .NET Core ile geliştirilen Enterprise uygulamaların omurgasını oluşturur. Her pattern bir soruna çözüm üretirken, yanlış kullanımı yeni sorunlara yol açabilir. Proje ölçeğine göre doğru aracı seçmek mimarın en önemli görevidir.
        </div>

    </div>
</body>
</html>
