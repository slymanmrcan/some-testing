den</td>
                <td>Yetki yetersiz (Rol/Policy hatası)</td>
                <td>Admin paneline erişim denemesi</td>
            </tr>
            <tr>
                <td>404 Not Found</td>
                <td>Kaynak bulunamadı</td>
                <td>ID ile kayıt arama sonucu boş</td>
            </tr>
            <tr>
                <td>500 Server Error</td>
                <td>Beklenmeyen hata</td>
                <td>Database bağlantı kopukluğu</td>
            </tr>
        </table>

        <h2 id="result-pattern">Result Pattern</h2>
        
        <p>Result Pattern, Service katmanından Controller'a veya katmanlar arası veri taşırken kullanılan, işlemin sonucunu ve veriyi kapsülleyen bir yapıdır. Exception fırlatmak yerine "başarısızlık" durumunu bir nesne olarak döndürmeyi hedefler.</p>

        <div class="info-box">
            <strong>Exception vs Result:</strong> Business logic akışında (örneğin "Bakiye yetersiz") Exception fırlatmak performans maliyetlidir (Stack trace oluşumu). Bunun yerine <code>Result.Failure("Bakiye yetersiz")</code> döndürmek hem daha hızlıdır hem de akış kontrolünü kolaylaştırır.
        </div>

        <h3>Yapısal Bileşenler</h3>
        <ul>
            <li><strong>IsSuccess:</strong> İşlemin başarılı olup olmadığını belirten boolean.</li>
            <li><strong>Value:</strong> Başarılı durumda taşınan veri.</li>
            <li><strong>Error:</strong> Başarısız durumda hata mesajı veya hata objesi.</li>
            <li><strong>ValidationErrors:</strong> Varsa validasyon hatalarının listesi.</li>
        </ul>

        <h4>Kod Örneği (Implicit Operators):</h4>
        <pre><code>
public class Result<T>
{
    public bool IsSuccess { get; }
    public T Value { get; }
    public string Error { get; }

    // Implicit conversion sayesinde kod temizliği
    public static implicit operator Result<T>(T value) => Success(value);
    public static implicit operator Result<T>(string error) => Failure(error);
}
        </code></pre>

        <h2 id="multi-db">Multiple Database Kullanımı</h2>

        <h3 id="multi-db-same">Aynı Tip DB (Sharding/Tenancy)</h3>
        <p>Multi-tenant uygulamalarda veya sharding senaryolarında, şema aynı olsa da veritabanı sunucusu veya veritabanı adı değişebilir.</p>
        
        <ul>
            <li><strong>DbContextFactory:</strong> Her request'te tenant ID'ye göre connection string dinamik olarak belirlenir.</li>
            <li><strong>Catalog Pattern:</strong> Ana bir veritabanında hangi tenant'ın hangi connection string'i kullanacağı tutulur.</li>
        </ul>

        <h3 id="multi-db-different">Farklı Tip DB (Polyglot Persistence)</h3>
        <p>Modern mimarilerde her veri tipi için en uygun veritabanı teknolojisi seçilir. CQRS bu yapıyı destekler.</p>

        <table class="comparison-table">
            <tr>
                <th>Veritabanı Tipi</th>
                <th>Kullanım Alanı</th>
                <th>Örnek Teknoloji</th>
            </tr>
            <tr>
                <td>Relational (RDBMS)</td>
                <td>İlişkisel veriler, Transactional işlemler (Write Side)</td>
                <td>SQL Server, PostgreSQL</td>
            </tr>
            <tr>
                <td>NoSQL (Document)</td>
                <td>Ürün katalogları, JSON veriler, Read Side</td>
                <td>MongoDB, Couchbase</td>
            </tr>
            <tr>
                <td>Key-Value Store</td>
                <td>Caching, Session yönetimi</td>
                <td>Redis</td>
            </tr>
            <tr>
                <td>Search Engine</td>
                <td>Full-text search, Log analizi</td>
                <td>Elasticsearch</td>
            </tr>
        </table>

        <div class="note-box">
            <strong>Distributed Transaction Sorunu:</strong> Birden fazla veritabanına aynı anda yazma işlemi yapıldığında (örneğin SQL'e sipariş, Mongo'ya log atma) veri bütünlüğü risk altındadır. Bu durumda <strong>Saga Pattern</strong> veya <strong>Outbox Pattern</strong> kullanılmalıdır.
        </div>

        <h2 id="advanced">İleri Seviye Konular</h2>
        
        <h3>1. Specification Pattern</h3>
        <p>Generic Repository pattern'deki <code>Expression&lt;Func&lt;T, bool&gt;&gt;</code> karmaşasını önlemek için kullanılır. İş kurallarını (sorguları) yeniden kullanılabilir nesneler haline getirir.</p>

        <h3>2. Options Pattern</h3>
        <p><code>appsettings.json</code> içerisindeki konfigürasyonları, strongly-typed sınıflara mapleyerek dependency injection ile yönetmeyi sağlar. <code>IOptions</code>, <code>IOptionsSnapshot</code> ve <code>IOptionsMonitor</code> arayüzleri ile canlı konfigürasyon takibi yapılabilir.</p>

        <h3>3. Background Services (Hosted Services)</h3>
        <p>Uygulama ayağa kalktığında veya belirli periyotlarda çalışması gereken işler için kullanılır (Email kuyruğu eritme, Cache yenileme vb.).</p>
        
        <div class="success-box">
            <strong>Sonuç:</strong> Bu dokümantasyonda ele alınan pattern'ler, .NET Core ile geliştirilen Enterprise uygulamaların omurgasını oluşturur. Her pattern bir soruna çözüm üretirken, yanlış kullanımı yeni sorunlara yol açabilir. Proje ölçeğine göre doğru aracı seçmek mimarın en önemli görevidir.
        </div>

    </div>
</body>
</html>
